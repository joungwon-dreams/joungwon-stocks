"""
Portfolio AI Advisor - ë³´ìœ ì¢…ëª© AI í”¼ë“œë°± ì‹œìŠ¤í…œ
ë§¤ì¼ AIê°€ íˆ¬ì íŒë‹¨ì„ ì œì‹œí•˜ê³ , ë‹¤ìŒë‚  ê²°ê³¼ë¡œ ê²€ì¦

ê²€ì¦ ì£¼ê¸°: 1ì¼ (ì–´ì œ íŒë‹¨ â†’ ì˜¤ëŠ˜ ê²°ê³¼)
AI: Google Gemini API ì‚¬ìš©
"""
import asyncio
import os
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Optional, Dict, Any, List

import google.generativeai as genai

import sys
sys.path.insert(0, '/Users/wonny/Dev/joungwon.stocks')
from src.config.database import db


class PortfolioAdvisor:
    """ë³´ìœ ì¢…ëª© AI í”¼ë“œë°± ì–´ë“œë°”ì´ì €"""

    RECOMMENDATION_MAP = {
        'BUY_MORE': 'ì¶”ê°€ ë§¤ìˆ˜',
        'HOLD': 'ê´€ë§',
        'SELL': 'ì¼ë¶€ ë§¤ë„',
        'CUT_LOSS': 'ì†ì ˆ'
    }

    RECOMMENDATION_EMOJI = {
        'BUY_MORE': 'ğŸŸ¢',
        'HOLD': 'âšª',
        'SELL': 'ğŸŸ¡',
        'CUT_LOSS': 'ğŸ”´'
    }

    def __init__(self):
        # Configure Gemini API
        api_key = os.getenv('GEMINI_API_KEY')
        if api_key:
            genai.configure(api_key=api_key)
            self.model = genai.GenerativeModel('gemini-2.0-flash-lite')
        else:
            self.model = None
            print("âš ï¸ GEMINI_API_KEY not set - PortfolioAdvisor will not work")

    async def check_cache(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """ì˜¤ëŠ˜ ì´ë¯¸ ìƒì„±ëœ AI íŒë‹¨ì´ ìˆëŠ”ì§€ ìºì‹œ í™•ì¸"""
        query = """
            SELECT recommendation, rationale, confidence
            FROM portfolio_ai_history
            WHERE stock_code = $1 AND report_date = CURRENT_DATE
        """
        result = await db.fetchrow(query, stock_code)
        if result:
            print(f"ğŸ’¾ ìºì‹œ ì ì¤‘: {stock_code} (ì˜¤ëŠ˜ ë°ì´í„° ì¬ì‚¬ìš©)")
            return {
                'recommendation': result['recommendation'],
                'rationale': result['rationale'],
                'confidence': float(result['confidence']) if result['confidence'] else 0.5,
                'review': '',
                'source': 'cache'
            }
        return None

    def generate_fallback_strategy(
        self,
        return_rate: float,
        investor_data: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        API ì‹¤íŒ¨ ì‹œ ê·œì¹™ ê¸°ë°˜ Fallback ì „ëµ ìƒì„±

        ê·œì¹™:
        - ì†ì‹¤ë¥  -10% ë¯¸ë§Œ + ì™¸êµ­ì¸ ë§¤ìˆ˜ â†’ BUY_MORE
        - ì†ì‹¤ë¥  -10% ë¯¸ë§Œ + ë§¤ë„ì„¸ â†’ HOLD
        - ìˆ˜ìµë¥  +10% ì´ˆê³¼ â†’ SELL
        - ê¸°íƒ€ â†’ HOLD
        """
        foreign_5d = investor_data.get('foreign_5d', 0) if investor_data else 0
        institutional_5d = investor_data.get('institutional_5d', 0) if investor_data else 0

        recommendation = 'HOLD'
        rationale = 'íŠ¹ì´ ì‚¬í•­ì´ ì—†ì–´ í˜„ ì¶”ì„¸ë¥¼ ê´€ë§í•©ë‹ˆë‹¤.'
        confidence = 0.4

        if return_rate < -10:
            if foreign_5d > 0:
                recommendation = 'BUY_MORE'
                rationale = 'ë‚™í­ ê³¼ëŒ€ êµ¬ê°„ì—ì„œ ì™¸êµ­ì¸ ìˆ˜ê¸‰ì´ ìœ ì…ë˜ê³  ìˆì–´ ë¶„í•  ë§¤ìˆ˜ ê¸°íšŒë¡œ ë³´ì…ë‹ˆë‹¤.'
                confidence = 0.5
            else:
                recommendation = 'HOLD'
                rationale = 'í•˜ë½ì„¸ê°€ ì§€ì†ë˜ê³  ìˆì–´ ë°”ë‹¥ í™•ì¸ ì „ê¹Œì§€ ê´€ë§ì„ ê¶Œì¥í•©ë‹ˆë‹¤.'
                confidence = 0.4
        elif return_rate > 10:
            recommendation = 'SELL'
            rationale = 'ëª©í‘œ ìˆ˜ìµë¥  ë„ë‹¬ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë¯€ë¡œ ë¶€ë¶„ ì´ìµ ì‹¤í˜„ì„ ê³ ë ¤í•˜ì„¸ìš”.'
            confidence = 0.6
        elif return_rate < -5 and (foreign_5d > 0 or institutional_5d > 0):
            recommendation = 'BUY_MORE'
            rationale = 'ì¡°ì • êµ¬ê°„ì—ì„œ ê¸°ê´€/ì™¸êµ­ì¸ ë§¤ìˆ˜ì„¸ê°€ ê°ì§€ë©ë‹ˆë‹¤. ë¶„í•  ë§¤ìˆ˜ ê³ ë ¤ ê°€ëŠ¥í•©ë‹ˆë‹¤.'
            confidence = 0.45

        rationale += ' *(Note: AI quota exceeded. Strategy generated by quantitative rules.)*'

        print(f"ğŸ”„ Fallback ì „ëµ ì ìš©: {recommendation}")
        return {
            'recommendation': recommendation,
            'rationale': rationale,
            'confidence': confidence,
            'review': '',
            'source': 'fallback'
        }

    async def get_yesterday_advice(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """ì–´ì œì˜ AI íŒë‹¨ì„ ì¡°íšŒ (ê²€ì¦ë˜ì§€ ì•Šì€ ê²ƒ)"""
        query = """
            SELECT id, stock_code, report_date, my_avg_price, market_price, return_rate,
                   recommendation, rationale, confidence, is_verified,
                   next_day_price, next_day_return, was_correct, created_at, verified_at
            FROM portfolio_ai_history
            WHERE stock_code = $1
              AND report_date = CURRENT_DATE - INTERVAL '1 day'
              AND is_verified = FALSE
            ORDER BY created_at DESC
            LIMIT 1
        """
        result = await db.fetchrow(query, stock_code)
        return dict(result) if result else None

    async def get_latest_advice(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """ê°€ì¥ ìµœê·¼ AI íŒë‹¨ì„ ì¡°íšŒ (ì˜¤ëŠ˜ ê²ƒ í¬í•¨)"""
        query = """
            SELECT id, stock_code, report_date, my_avg_price, market_price, return_rate,
                   recommendation, rationale, confidence, is_verified,
                   next_day_price, next_day_return, was_correct, created_at, verified_at
            FROM portfolio_ai_history
            WHERE stock_code = $1
            ORDER BY report_date DESC, created_at DESC
            LIMIT 1
        """
        result = await db.fetchrow(query, stock_code)
        return dict(result) if result else None

    async def verify_yesterday_advice(self, stock_code: str, today_price: float) -> Optional[Dict[str, Any]]:
        """
        ì–´ì œ íŒë‹¨ì„ ì˜¤ëŠ˜ ê°€ê²©ìœ¼ë¡œ ê²€ì¦

        ê²€ì¦ ë¡œì§:
        - BUY_MORE ì¶”ì²œ â†’ ì˜¤ëŠ˜ ìƒìŠ¹í–ˆìœ¼ë©´ was_correct = TRUE
        - SELL/CUT_LOSS ì¶”ì²œ â†’ ì˜¤ëŠ˜ í•˜ë½í–ˆìœ¼ë©´ was_correct = TRUE
        - HOLD ì¶”ì²œ â†’ ë³€ë™í­ Â±1% ì´ë‚´ë©´ was_correct = TRUE
        """
        yesterday = await self.get_yesterday_advice(stock_code)
        if not yesterday:
            return None

        yesterday_price = float(yesterday['market_price'])
        next_day_return = ((today_price - yesterday_price) / yesterday_price) * 100

        recommendation = yesterday['recommendation']
        was_correct = False

        if recommendation == 'BUY_MORE':
            was_correct = next_day_return > 0  # ìƒìŠ¹í•˜ë©´ ì ì¤‘
        elif recommendation in ['SELL', 'CUT_LOSS']:
            was_correct = next_day_return < 0  # í•˜ë½í•˜ë©´ ì ì¤‘
        elif recommendation == 'HOLD':
            was_correct = abs(next_day_return) <= 1.0  # Â±1% ì´ë‚´ë©´ ì ì¤‘

        # DB ì—…ë°ì´íŠ¸
        update_query = """
            UPDATE portfolio_ai_history
            SET is_verified = TRUE,
                next_day_price = $1,
                next_day_return = $2,
                was_correct = $3,
                verified_at = NOW()
            WHERE id = $4
        """
        await db.execute(update_query, today_price, next_day_return, was_correct, yesterday['id'])

        # ì—…ë°ì´íŠ¸ëœ ê²°ê³¼ ë°˜í™˜
        yesterday['next_day_price'] = today_price
        yesterday['next_day_return'] = next_day_return
        yesterday['was_correct'] = was_correct
        yesterday['is_verified'] = True

        return yesterday

    async def generate_strategy(
        self,
        stock_code: str,
        stock_name: str,
        avg_buy_price: float,
        current_price: float,
        investor_data: Optional[Dict] = None,
        news_summary: Optional[str] = None,
        yesterday_advice: Optional[Dict] = None,
        price_history: Optional[List[Dict]] = None,
        use_cache: bool = True
    ) -> Dict[str, Any]:
        """
        Gemini AIë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜¤ëŠ˜ì˜ íˆ¬ì ì „ëµ ìƒì„±

        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            stock_name: ì¢…ëª©ëª…
            avg_buy_price: í‰ê·  ë§¤ìˆ˜ê°€
            current_price: í˜„ì¬ê°€
            investor_data: ìˆ˜ê¸‰ ë°ì´í„° (ì™¸êµ­ì¸/ê¸°ê´€ ìˆœë§¤ìˆ˜)
            news_summary: ìµœê·¼ ë‰´ìŠ¤ ìš”ì•½
            yesterday_advice: ì–´ì œ AI íŒë‹¨ ë° ê²€ì¦ ê²°ê³¼
            price_history: ìµœê·¼ ê°€ê²© ì´ë ¥
            use_cache: ìºì‹œ ì‚¬ìš© ì—¬ë¶€ (ê¸°ë³¸: True)

        Returns:
            {
                'recommendation': 'BUY_MORE' | 'HOLD' | 'SELL' | 'CUT_LOSS',
                'rationale': str,
                'confidence': float (0.0 ~ 1.0),
                'review': str (ì–´ì œ íŒë‹¨ì— ëŒ€í•œ íšŒê³ ),
                'source': 'ai' | 'cache' | 'fallback'
            }
        """
        return_rate = ((current_price - avg_buy_price) / avg_buy_price) * 100

        # 1. ìºì‹œ í™•ì¸ (ì˜¤ëŠ˜ ì´ë¯¸ ë¶„ì„í•œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì¬ì‚¬ìš©)
        if use_cache:
            cached = await self.check_cache(stock_code)
            if cached:
                return cached

        # 2. Gemini API ë¯¸ì„¤ì • ì‹œ Fallback
        if not self.model:
            print("âš ï¸ Gemini API ë¯¸ì„¤ì • - Fallback ì „ëµ ì‚¬ìš©")
            return self.generate_fallback_strategy(return_rate, investor_data)

        # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        prompt = f"""ë‹¹ì‹ ì€ ì—„ê²©í•œ í¬íŠ¸í´ë¦¬ì˜¤ ë§¤ë‹ˆì €ì…ë‹ˆë‹¤. ë‹¤ìŒ ì¢…ëª©ì— ëŒ€í•œ íˆ¬ì íŒë‹¨ì„ ë‚´ë ¤ì£¼ì„¸ìš”.

## ì¢…ëª© ì •ë³´
- ì¢…ëª©ëª…: {stock_name} ({stock_code})
- ë‚´ í‰ê·  ë§¤ìˆ˜ê°€: {int(avg_buy_price):,}ì›
- í˜„ì¬ê°€: {int(current_price):,}ì›
- í˜„ì¬ ìˆ˜ìµë¥ : {return_rate:+.2f}%
"""

        if price_history:
            prompt += "\n## ìµœê·¼ ê°€ê²© ì¶”ì´\n"
            for p in price_history[-10:]:
                prompt += f"- {p.get('date', 'N/A')}: {int(p.get('close', 0)):,}ì›"
                if p.get('change_pct'):
                    prompt += f" ({p['change_pct']:+.2f}%)"
                if p.get('volume'):
                    prompt += f" ê±°ë˜ëŸ‰:{p['volume']:,}"
                prompt += "\n"

        if investor_data:
            prompt += f"""
## ìˆ˜ê¸‰ ì •ë³´ (ìµœê·¼ 5ì¼)
- ì™¸êµ­ì¸ ìˆœë§¤ìˆ˜: {investor_data.get('foreign_5d', 0):+,}ì£¼
- ê¸°ê´€ ìˆœë§¤ìˆ˜: {investor_data.get('institutional_5d', 0):+,}ì£¼
"""

        if news_summary:
            prompt += f"""
## ìµœê·¼ ë‰´ìŠ¤ ìš”ì•½
{news_summary}
"""

        if yesterday_advice:
            prompt += f"""
## ì–´ì œ AI íŒë‹¨ (ê²€ì¦ ê²°ê³¼)
- ì–´ì œ ì˜ê²¬: {self.RECOMMENDATION_MAP.get(yesterday_advice['recommendation'], 'ì•Œ ìˆ˜ ì—†ìŒ')}
- ì–´ì œ ì¢…ê°€: {int(yesterday_advice['market_price']):,}ì›
- ì˜¤ëŠ˜ ì¢…ê°€: {int(yesterday_advice.get('next_day_price', current_price)):,}ì›
- ê²°ê³¼: {yesterday_advice.get('next_day_return', 0):+.2f}%
- ì ì¤‘ ì—¬ë¶€: {'âœ… ì ì¤‘' if yesterday_advice.get('was_correct') else 'âŒ ì‹¤íŒ¨'}
"""

        prompt += """
## ì§€ì‹œì‚¬í•­
1. ìœ„ ì •ë³´ë¥¼ ì¢…í•©í•˜ì—¬ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì˜ í–‰ë™ì„ ì¶”ì²œí•˜ì„¸ìš”:
   - BUY_MORE: ì¶”ê°€ ë§¤ìˆ˜ (ì €í‰ê°€ êµ¬ê°„, ìˆ˜ê¸‰ ì–‘í˜¸)
   - HOLD: ê´€ë§ (ì¶”ì„¸ ë¶ˆë¶„ëª…, ëŒ€ê¸°)
   - SELL: ì¼ë¶€ ë§¤ë„ (ê³ ì  ê·¼ì²˜, ì°¨ìµì‹¤í˜„)
   - CUT_LOSS: ì†ì ˆ (í•˜ë½ ì¶”ì„¸ ì§€ì†, ì†ì‹¤ í™•ëŒ€ ë°©ì§€)

2. ë°˜ë“œì‹œ ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”:
{
    "recommendation": "BUY_MORE" | "HOLD" | "SELL" | "CUT_LOSS",
    "rationale": "íŒë‹¨ ì´ìœ ë¥¼ í•œêµ­ì–´ë¡œ 2-3ë¬¸ì¥ìœ¼ë¡œ ì‘ì„±",
    "confidence": 0.0 ~ 1.0 ì‚¬ì´ì˜ ì‹ ë¢°ë„,
    "review": "ì–´ì œ íŒë‹¨ì— ëŒ€í•œ íšŒê³  (ìˆëŠ” ê²½ìš°)"
}

JSONë§Œ ì¶œë ¥í•˜ì„¸ìš”. ë‹¤ë¥¸ í…ìŠ¤íŠ¸ëŠ” ì¶œë ¥í•˜ì§€ ë§ˆì„¸ìš”.
"""

        try:
            response = self.model.generate_content(prompt)
            response_text = response.text.strip()

            # JSON íŒŒì‹±
            import json
            # JSON ë¸”ë¡ ì¶”ì¶œ
            if '```json' in response_text:
                response_text = response_text.split('```json')[1].split('```')[0].strip()
            elif '```' in response_text:
                response_text = response_text.split('```')[1].split('```')[0].strip()

            result = json.loads(response_text)

            # ìœ íš¨ì„± ê²€ì‚¬
            if result.get('recommendation') not in ['BUY_MORE', 'HOLD', 'SELL', 'CUT_LOSS']:
                result['recommendation'] = 'HOLD'

            result['confidence'] = max(0.0, min(1.0, float(result.get('confidence', 0.5))))
            result['source'] = 'ai'

            print(f"âœ… Gemini AI ë¶„ì„ ì™„ë£Œ: {result['recommendation']}")
            return result

        except Exception as e:
            print(f"âŒ Gemini API ì˜¤ë¥˜: {e}")
            # API ì‹¤íŒ¨ ì‹œ Fallback ì „ëµ ì‚¬ìš©
            return self.generate_fallback_strategy(return_rate, investor_data)

    async def save_decision(
        self,
        stock_code: str,
        avg_buy_price: float,
        market_price: float,
        recommendation: str,
        rationale: str,
        confidence: float
    ) -> int:
        """ì˜¤ëŠ˜ì˜ AI íŒë‹¨ì„ DBì— ì €ì¥"""
        return_rate = ((market_price - avg_buy_price) / avg_buy_price) * 100

        query = """
            INSERT INTO portfolio_ai_history
                (stock_code, report_date, my_avg_price, market_price, return_rate,
                 recommendation, rationale, confidence)
            VALUES ($1, CURRENT_DATE, $2, $3, $4, $5, $6, $7)
            ON CONFLICT (stock_code, report_date)
            DO UPDATE SET
                my_avg_price = EXCLUDED.my_avg_price,
                market_price = EXCLUDED.market_price,
                return_rate = EXCLUDED.return_rate,
                recommendation = EXCLUDED.recommendation,
                rationale = EXCLUDED.rationale,
                confidence = EXCLUDED.confidence,
                created_at = NOW()
            RETURNING id
        """
        result = await db.fetchval(
            query,
            stock_code, avg_buy_price, market_price, return_rate,
            recommendation, rationale, confidence
        )
        return result

    async def get_verification_stats(self, stock_code: str, days: int = 30) -> Dict[str, Any]:
        """ìµœê·¼ Nì¼ê°„ AI íŒë‹¨ ì ì¤‘ë¥  í†µê³„"""
        query = """
            SELECT
                COUNT(*) as total,
                SUM(CASE WHEN was_correct THEN 1 ELSE 0 END) as correct,
                AVG(CASE WHEN was_correct THEN 1 ELSE 0 END) * 100 as accuracy,
                AVG(next_day_return) as avg_return
            FROM portfolio_ai_history
            WHERE stock_code = $1
              AND is_verified = TRUE
              AND report_date >= CURRENT_DATE - $2 * INTERVAL '1 day'
        """
        result = await db.fetchrow(query, stock_code, days)

        return {
            'total': result['total'] or 0,
            'correct': result['correct'] or 0,
            'accuracy': float(result['accuracy'] or 0),
            'avg_return': float(result['avg_return'] or 0)
        }

    async def process_daily_feedback(
        self,
        stock_code: str,
        stock_name: str,
        avg_buy_price: float,
        current_price: float,
        investor_data: Optional[Dict] = None,
        news_summary: Optional[str] = None,
        price_history: Optional[List[Dict]] = None
    ) -> Dict[str, Any]:
        """
        ì¼ì¼ í”¼ë“œë°± ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
        1. ì–´ì œ íŒë‹¨ ì¡°íšŒ ë° ê²€ì¦
        2. ì˜¤ëŠ˜ íŒë‹¨ ìƒì„±
        3. DB ì €ì¥
        4. ê²°ê³¼ ë°˜í™˜
        """
        # 1. ì–´ì œ íŒë‹¨ ê²€ì¦
        verified_yesterday = await self.verify_yesterday_advice(stock_code, current_price)

        # 2. ì˜¤ëŠ˜ íŒë‹¨ ìƒì„±
        today_strategy = await self.generate_strategy(
            stock_code=stock_code,
            stock_name=stock_name,
            avg_buy_price=avg_buy_price,
            current_price=current_price,
            investor_data=investor_data,
            news_summary=news_summary,
            yesterday_advice=verified_yesterday,
            price_history=price_history
        )

        # 3. DB ì €ì¥
        saved_id = await self.save_decision(
            stock_code=stock_code,
            avg_buy_price=avg_buy_price,
            market_price=current_price,
            recommendation=today_strategy['recommendation'],
            rationale=today_strategy['rationale'],
            confidence=today_strategy['confidence']
        )

        # 4. ê²°ê³¼ ë°˜í™˜
        return {
            'stock_code': stock_code,
            'stock_name': stock_name,
            'yesterday_review': verified_yesterday,
            'today_strategy': today_strategy,
            'saved_id': saved_id
        }


# í…ŒìŠ¤íŠ¸ìš©
async def test_advisor():
    """í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
    await db.connect()
    try:
        advisor = PortfolioAdvisor()

        # í…ŒìŠ¤íŠ¸ ì¢…ëª© (í•œêµ­ì „ë ¥)
        result = await advisor.process_daily_feedback(
            stock_code='015760',
            stock_name='í•œêµ­ì „ë ¥',
            avg_buy_price=22000,
            current_price=21500,
            investor_data={'foreign_5d': -50000, 'institutional_5d': 30000},
            news_summary='ì „ê¸°ìš”ê¸ˆ ì¸ìƒ ë…¼ì˜ ì¤‘, ì •ë¶€ ì •ì±… ë³€í™” ì˜ˆìƒ'
        )

        print("\n===== AI í”¼ë“œë°± ê²°ê³¼ =====")
        print(f"ì¢…ëª©: {result['stock_name']}")

        if result['yesterday_review']:
            y = result['yesterday_review']
            print(f"\n[ì–´ì œ íšŒê³ ]")
            print(f"  ì˜ê²¬: {advisor.RECOMMENDATION_MAP.get(y['recommendation'])}")
            print(f"  ê²°ê³¼: {y.get('next_day_return', 0):+.2f}%")
            print(f"  ì ì¤‘: {'âœ…' if y.get('was_correct') else 'âŒ'}")

        t = result['today_strategy']
        print(f"\n[ì˜¤ëŠ˜ ì „ëµ]")
        print(f"  ì¶”ì²œ: {advisor.RECOMMENDATION_EMOJI.get(t['recommendation'])} {advisor.RECOMMENDATION_MAP.get(t['recommendation'])}")
        print(f"  ì´ìœ : {t['rationale']}")
        print(f"  ì‹ ë¢°ë„: {t['confidence']*100:.0f}%")

    finally:
        await db.disconnect()


if __name__ == '__main__':
    asyncio.run(test_advisor())
